/*
 * The main file. The execution of the kernel begins from here.
 *
 * Copyright (c) by Tapti Palit. All rights reserved.
 *
 */

#include <defs.h>
#include <stdio.h>

void clear_terminal(void);
void init_timer(int);

extern void reset_terminal_cursor();
extern void init_timer(int);
extern void initialize_gdt();
extern void initialize_idt();

void start(void* modulep, void* physbase, void* physfree)
{
	/*
	struct smap_t {
		uint64_t base, length;
		uint32_t type;
	}__attribute__((packed)) *smap;
	while(modulep[0] != 0x9001) modulep += modulep[1]+2;
	for(smap = (struct smap_t*)(modulep+2); smap < (struct smap_t*)((char*)modulep+modulep[1]+2*4); ++smap) {
		if (smap->type == 1  && smap->length != 0) {
			kprintf("Available Physical Memory [%x-%x]\n", smap->base, smap->base + smap->length);
		}
	}*/
	// kernel starts here
	while(1);
	/*n
      	int improb_drive = 11;
	clear_terminal();
	kprintf("\t\t\tBooted SBUnix...\n");
	kprintf("%d is the answer to %s\n", 43, "everything");
	kprintf("The value of the improbability drive in base 16: %x\n", improb_drive);
       	kprintf("The improbability drive is at %p\n", &improb_drive);
	*/

}

#define INITIAL_STACK_SIZE 4096
char stack[INITIAL_STACK_SIZE];
uint32_t* loader_stack;
extern char kernmem, physbase;

void boot(void)
{
	// note: function changes rsp, local stack variables can't be practically used
	volatile register char *rsp asm ("rsp");
	loader_stack = (uint32_t*)rsp;
	rsp = &stack[INITIAL_STACK_SIZE];
	initialize_gdt();
       	initialize_idt();
	init_timer(100);
	start(
		(char*)(uint64_t)loader_stack[3] + (uint64_t)&kernmem - (uint64_t)&physbase,
		&physbase,
		(void*)(uint64_t)loader_stack[4]
	);
	while(1);
}

void clear_terminal()
{
	int i,j;
	for(i=0; i<=80; i++){
		for(j=0; j<=25; j++){
			putchar(' ');
		}
	}
	reset_terminal_cursor();
}

